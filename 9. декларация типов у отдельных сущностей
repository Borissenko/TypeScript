= let
let name: string = 'Привет!'
let name = '' as string


перенятие типа от аналогичного поля в интерфейсе (лектор запутался)
interface Person {
  name: string
  age: number
}
type EtPerson = keyof Person
const name: EtPerson = 'Kola'




= []
А) Перед "=".
1.
const aa: number[] = [1, 2, 3, 4]
const aa: User[] = [User, User, User]               //BEST(!)  User- это нами прописанный интарфейс.
const dd: number[][] = [[1,2,3,4,5], [6,7,8,9,10]]   //массив из массивов
const dd: (number | string)[] = ['Age', 20]      //несколько возможных типов ВРАЗБРОД

2.
const cc: [number, string] = [1, 'kola']   //НЕ НАДО ТАК(!), жесткое описание типа в каждой ячейке массива. Это Tuples-тип.
3.
const bb: Array<number> = [1, 2, 3, 4]

B) После "=".
4.
const arr = <User[]>[]         //BEST(!)
const arr = <string[]>[]
5.
const arr = [] as User[]
6.
const arr = new Array<User>()     //Using the Array constructor, еще лучше.




= {}
  state: {
    token: 'false',
    groups: [],
    tasks: ''
  } as unknown as St

....
CHANGE_STATUS(st: RootState, {id, newValue}: {id: number; newValue: string;})


= function
1.
function f1(a: string, name?: string, age: number = 25): void {
    console.log(a)
}
?   - не обязательный аргумент
25  - значение по-умолчанию


2. Если может возвращатся массив, НО ПУСТОЙ, то надо прописывать именно так(!).
    ...
    return <User[]>[]
}

или тоже можно так
   ...
   let temp: User[] = [];
   return temp
 }





= стрелочная функция
() => number

??
ACCEPT_ITEM: (state: RootState) => (id: number) => state.tasks.find((it: Task) => it.id === id) as Task,
ACCEPT_ITEM: (state: RootState): (id: number) => (Task | undefined) => (id: number): Task | undefined => state.tasks.find((it: Task) => it.id === id),
ACCEPT_ITEM: (state: RootState): (Task | undefined) => (id: number): Task | undefined => state.tasks.find((it: Task) => it.id === id),



= аргументы у методов (здесь- метод массивов [].length)
let dd: any = 'Привет'   //заявляем "массив"

(dd as string).length
(<string>dd).length




= class
class Add impliment Person {                //Person- это применяемый интерфейс
 name: "Kola"
}


=Promise
:Promise<User> | undefined
new Promise<IPlayer>()