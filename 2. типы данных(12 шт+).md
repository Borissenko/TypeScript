# Типы данных(12 шт):

А.
-boolean, number, string, null, undefined
-array object
-tuple (массив с разными типами данных), Нр: (string | number)[] (?)

-enum  (перечисление) 

-any    - можно присваивать значения с разными типами
-void   - функция ничего не возвращает
-never   - функция без завершения, в теле прописано throw new Error('ups...') или вечный цикл.
-never[] - любое, кроме [].

-Promise<...> | undefined 





Б.
собственный тип (alias)
type Human = {firstName: string, age: number, height: number}
const dd: Human = {firstName: ‘Franz’, age: 32, height: 185}

type point = string | number | null | undefined
const qq: point = 'go!'




В.
собственный тип с КОНКРЕТНЫМ значением
type point = 'success' | 'danger' | 'warning'

function setAlert (x: point) {
    console.log(x)
}
setAlert('success')    // код валидный
setAlert('Привет!')    // код выдаст ошибку






Г.
Тип данных для {}- через заявленный CLASS.

>1. класс БЕЗ значений его полей
# заявление класса с типизацией его полей
class My {
  dd: number             //у классов запятой нет
  readonly kk: number
}

# использование типа при декларации функции
function ff (x: My): void {
  console.log(x.dd)
}

# вызов функции
const ss = {
  dd: 3, 
  kk: 55
}
ff(ss)


>2. класс C КОНКРЕТНЫМИ значениями у его полей
- т.е. аргументу функции позволяем вставлять только КОНКРЕТНОЕ ЗНАЧЕНИЕ его аргумента
# заявление типа
class Massege {
  dd: "Привет"   //у классов запятой нет
  kk: "Пока"
}

# использование
function ff (x: Massege): void {
  console.log(x.dd)
}
ff()






Д. ИНТЕРФЕЙСЫ для объектов
Интерфейсы содержат свойства и методы кастомного типы, но не содержат их реализацию. 
Реализацию берёт на себя класс, реализующий интерфейс.
В примере выше в первом свойстве реализуется интерфейс Person. 
Попытка реализации интерфейса в переменной person2 выбросит исключение.

а) интерфейс простой
interface Person {
 name: string
}
const person: Person = {name: 'Gabriel'}
const person2: Person = {names: 'Gabriel'} // Тип Person не присваивается

б) вложенные интерфейсы
interface Family extend Person {  //расширяется за счет...
count: () => number
age: number
}

в) интерфейс без детализации полей
- может содержать множество любых полей,
где имя полей- string, а их значение- string.

interface Pride {
 [key: string]: string
}






Е. enum  (перечисление) 
а) заявление 
enum Family {
  father,  //ему автоматически присваевается значение, равное его индексу
  mother,
  sister,
  brother
}
enum Family_2 {
  father = 4
  mother = 2
  sister = 'Lana'
  brother = 'Nick'
}

б) использование
const ss = Family.brother    //=> 3
const aa = Family[2]         //=> 'sister'

const ss = Family_2.brother    //=> 'Nick'








Ж. ДЖЕНЕРИКИ  (кроме T есть еще S,P,R ...)
Генерируемые типы данных (Дженерики)
- что бы функция могла работать с разными типами аргументов

const nn: Array<number> = [1, 2, 3, 4]
const ss: Array<string> = ['a','s','d']

function fu<T>(x: T[]): T[] {   // T- генерируемый тип данных
    return x.reverse()
}

fu(nn)
fu(ss)  //красным не подчеркивается, т.е. все валидно


Дженерики (англ. generics) позволяют создавать компоненты, которые совместимы с большим количеством типов, а не только с одним. Это делает компоненты более «открытыми».
Возможно у вас возникнет вопрос: а почему бы не использовать тип any.

function dummyFun(arg: any): any {
 return arg;
}
При использовании типа any у вас не получится узнать оригинальный тип передаваемой переменной.
Как можно это реализовать с помощью дженерика:

function dummyFun(arg: T): T {
 return arg
}

В этом коде используется generic-параметр T, тип которого можно будет захватить и в дальнейшем использовать.
https://medium.com/@wittydeveloper/typescript-generics-and-overloads-999679d121cf








